{"meta":{"title":null,"subtitle":null,"description":"php mysql","author":"shudun","url":"https://www.baidu.com","root":"/"},"pages":[{"title":"","date":"2020-01-01T05:21:54.923Z","updated":"2019-12-20T11:21:47.684Z","comments":true,"path":"404.html","permalink":"https://www.baidu.com/404.html","excerpt":"","text":""},{"title":"Archives","date":"2017-03-20T12:49:56.000Z","updated":"2019-12-20T11:21:47.699Z","comments":false,"path":"archive/index.html","permalink":"https://www.baidu.com/archive/index.html","excerpt":"","text":""},{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2019-12-21T04:51:52.135Z","comments":true,"path":"about/index.html","permalink":"https://www.baidu.com/about/index.html","excerpt":"","text":"email: shudun.yum@gmail.com&nbsp;"},{"title":"Photography","date":"2019-12-08T12:48:22.000Z","updated":"2019-12-23T07:40:31.203Z","comments":true,"path":"photography/index.html","permalink":"https://www.baidu.com/photography/index.html","excerpt":"","text":"干嘛的?"},{"title":"Tags","date":"2020-01-01T05:21:54.923Z","updated":"2019-12-20T11:21:47.790Z","comments":true,"path":"tags/index.html","permalink":"https://www.baidu.com/tags/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-01-01T13:15:42.353Z","updated":"2020-01-01T13:15:42.353Z","comments":true,"path":"index.html","permalink":"https://www.baidu.com/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-01-01T13:16:40.510Z","updated":"2020-01-01T13:16:40.510Z","comments":true,"path":"categories/index.html","permalink":"https://www.baidu.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2020-01-01T13:58:04.000Z","updated":"2020-01-01T13:58:04.567Z","comments":true,"path":"404/index.html","permalink":"https://www.baidu.com/404/index.html","excerpt":"","text":""},{"title":"search","date":"2020-01-01T13:57:55.000Z","updated":"2020-01-01T13:57:55.417Z","comments":true,"path":"search/index.html","permalink":"https://www.baidu.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"使用反射实现依赖 自动注入","slug":"使用反射实现依赖注入","date":"2019-05-14T13:21:43.000Z","updated":"2020-02-05T05:47:49.146Z","comments":true,"path":"2019/05/14/使用反射实现依赖注入/","link":"","permalink":"https://www.baidu.com/2019/05/14/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"以laravel框架为例, 很多地方出现如下代码: 声明个基类, 实例化时, 同时注入AdminUserService类123456789class BaseController&#123; protected $userService; public function __construct(UserService $userService) &#123; //依赖注入服务 $this -&gt; userService = $userService; &#125;&#125;声明UserService类, 同时构造一个run()方法123456class AdminUserService&#123; public function run() &#123; echo \"i 'm run func()\"; &#125;&#125;ok, 前置条件已准备完毕。现在创建个控制器, 继承上面的BaseController来使用依赖 123456class UserController extends BaseController &#123; public function index() &#123; $this-&gt;userService-&gt;run(); &#125;&#125; 好了可以使用了, 浏览器输入http://localhost/user/index 就能调用AdminUserService类的run()方法, 这里甚至不需要去实例化BaseController类, 不需要给构造函数传参, 因为框架内部使用了反射 帮你自动实例化对象, 自动传参了。下面自己实现一个类似的功能, 新建三个类","categories":[],"tags":[]},{"title":"使用socket, 实现简单的聊天","slug":"使用socket-实现简单的聊天","date":"2019-04-23T11:16:53.000Z","updated":"2020-01-23T13:09:38.265Z","comments":true,"path":"2019/04/23/使用socket-实现简单的聊天/","link":"","permalink":"https://www.baidu.com/2019/04/23/%E4%BD%BF%E7%94%A8socket-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%81%8A%E5%A4%A9/","excerpt":"","text":"原文地址看完后有所感悟，所以添加了些东东 先看效果图 是不是很简陋, 这样已经可以了。要想完善就慢慢的花时间改吧实现思路, 首先创建个主进程 SockerServer.php, 这样命名或许有点欠妥。但是我仍然暂理解为server123456789101112131415161718192021222324252627282930313233343536&lt;?phpif(($sock = socket_create(AF_INET, SOCK_STREAM, 0)) === false) &#123; echo \"failed to create socket: \".socket_strerror($sock) . PHP_EOL; die;&#125;$address = '127.0.0.1';$port = 88;if(($ret = socket_bind($sock, $address, $port)) &lt; === false) &#123; echo \"failed to bind socket: \".socket_strerror($ret) . PHP_EOL; die;&#125;if( ( $ret = socket_listen($sock, 0 ) ) === false ) &#123; echo \"failed to listen to socket: \".socket_strerror($ret) . PHP_EOL; die;&#125;while (true) &#123; $conn = socket_accept($sock); //主进程执行到此处,便不会往下执行. 它在等待接收新的socket. //如果有socket连接, 便fork一个 子进程 $fork = pcntl_fork(); if($fork == 0) &#123; $recv = socket_read($conn, 8192); if ($recv) &#123; list($name, $msg) = explode(\"|\", $recv); echo \"&#123;$name&#125; : &#123;$msg&#125;\"; die; &#125; &#125; else &#123; socket_close($conn); &#125;&#125;这样就可以了, 然后创建个 SockerClient.php 1234567891011121314151617181920212223$address = '127.0.0.1';$port = 88;echo \"insert your name:\"; //感觉insert比input合适$uname = fgets(STDIN);while(true) &#123;if (($createSock = socket_create(AF_INET, SOCK_STREAM, 0)) === false) &#123; echo \"create error :\" . socket_strerror($createSock); die;&#125;if (($sockCon = socket_connect($createSock, $address, $port)) === false) &#123; echo \"socket connect error: \". socket_strerror($sockCon); die;&#125; echo \"enter msg: \"; $msg = fgets(STDIN); socket_write($createSock, $uname . '|' . $msg); socket_close($createSock);&#125;","categories":[],"tags":[]},{"title":"go笔记 平台之间的交叉编译","slug":"go笔记-平台之间的交叉编译-1","date":"2019-02-28T10:45:22.000Z","updated":"2020-01-01T11:42:17.151Z","comments":true,"path":"2019/02/28/go笔记-平台之间的交叉编译-1/","link":"","permalink":"https://www.baidu.com/2019/02/28/go%E7%AC%94%E8%AE%B0-%E5%B9%B3%E5%8F%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91-1/","excerpt":"","text":"mac编译 linux, window64位 可执行程序12CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.golinux编译 mac, windows64位 可执行程序12CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go windows编译 Mac, Linux64位可执行程序123456789SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build main.goSET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build main.go","categories":[],"tags":[]},{"title":"php实现检测域名是否被墙","slug":"php实现检测域名是否被墙","date":"2018-12-24T06:03:11.000Z","updated":"2020-01-01T11:42:22.026Z","comments":true,"path":"2018/12/24/php实现检测域名是否被墙/","link":"","permalink":"https://www.baidu.com/2018/12/24/php%E5%AE%9E%E7%8E%B0%E6%A3%80%E6%B5%8B%E5%9F%9F%E5%90%8D%E6%98%AF%E5%90%A6%E8%A2%AB%E5%A2%99/","excerpt":"","text":"首先准备两台服务器,普通服务器一台, 能科学上网服务器一台.本人环境 php version 7.2 mysql5.7 1大概思路:境内主要发起http请求，如果响应失败，则尝试到境外服务器请求 存储结构12345678910111213141516SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;DROP TABLE IF EXISTS `tbl_url`;CREATE TABLE `tbl_url` ( `id` int(11) NOT NULL AUTO_INCREMENT, `in` tinyint(2) DEFAULT NULL, `out` tinyint(2) DEFAULT NULL, `note` varchar(255) DEFAULT NULL, `url` varchar(255) DEFAULT NULL, `created_at` datetime DEFAULT NULL, `updated_at` datetime DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;SET FOREIGN_KEY_CHECKS = 1; 普通服务器代码1234567891011121314151617181920212223242526272829303132333435363738394041424344try &#123; $pdo = new PDO( 'mysql:dbname=dbname;host=127.0.0.1;charset=UTF8', 'username', 'password' );&#125; catch ( Exception $ex ) &#123; exit;&#125;$update = function( $in, $out ) use ( $pdo, &amp;$id ) &#123; return 1 === $pdo-&gt;exec( sprintf( 'UPDATE `tbl_url` SET `in` = %d, `out` = %d, `updated_at` = NOW() WHERE `id` = %d LIMIT 1', $in, $out, $id ) );&#125;;curl_setopt_array( $ch = curl_init(), [ CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_TIMEOUT =&gt; 5,]);foreach( $pdo-&gt;query( 'SELECT `id`, `url` FROM `tbl_url` WHERE 1')-&gt;fetchAll( PDO::FETCH_KEY_PAIR ) as $id =&gt; $url ) &#123; curl_setopt( $ch, CURLOPT_URL, 'http://科学上网服务器地址/?url=' . base64_encode( $url ) ); switch( curl_exec( $ch ) ) &#123; case 1 : $update( 0, 1 ); break; case 2 : fsockopen( $url, 80, $en, $es, 4 ) ? $update( 2, 2 ) : $update( 1, 2 ); break; default : $update( 0, 0 ); &#125;&#125;curl_close( $ch ); 能科学上网的服务器代码12error_reporting(0); //这句必须加上, 因为fsockopen打不开的时候会返回warning。这是个api所以要保持数据能正确返回2或者1echo fsockopen( base64_decode( $_GET['url'] ), 80, $en, $es, 4 ) ? 2 : 1;","categories":[],"tags":[]},{"title":"使用redis set集合实现牛牛","slug":"使用redis-set集合实现牛牛","date":"2018-11-19T08:48:28.000Z","updated":"2020-01-21T09:00:26.321Z","comments":true,"path":"2018/11/19/使用redis-set集合实现牛牛/","link":"","permalink":"https://www.baidu.com/2018/11/19/%E4%BD%BF%E7%94%A8redis-set%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%89%9B%E7%89%9B/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpfunction webPuk() &#123; $redis = new Redis(); $redis-&gt;connect('127.0.0.1'); $randNum = -5; //随机发5张可能重复的牌 $totalNum = 5; //每个玩家几张牌 //这里c d h s分别代表 黑桃几，红桃几，方块几，梅花几 $redis-&gt;sadd('deck', 'CA', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10', 'CJ', 'CQ', 'CK', 'DA', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'D10', 'DJ', 'DQ', 'DK', 'HA', 'H2', 'H3', 'H4', 'H5', 'H6', 'H7', 'H8', 'H9', 'H10', 'HJ', 'HQ', 'HK', 'SA', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 'S10', 'SJ', 'SQ', 'SK'); //模拟三个三家玩斗牛 $result = $redis-&gt;SRANDMEMBER('deck', $randNum); $result2 = $redis-&gt;SRANDMEMBER('deck', $randNum); $result3 = $redis-&gt;SRANDMEMBER('deck', $randNum); echo $msg1 = \"玩家1: \" . PHP_EOL; foreach ($result as $k =&gt; $v) &#123; if ($k &gt; $totalNum) &#123; break; &#125; echo $v . PHP_EOL; &#125; echo \"&lt;br/&gt;\"; echo $msg2 = \"玩家2: \" . PHP_EOL; foreach ($result2 as $k =&gt; $v) &#123; if ($k &gt; $totalNum) &#123; break; &#125; echo $v . PHP_EOL; &#125; echo \"&lt;br/&gt;\"; echo $msg3 = \"玩家3: \" . PHP_EOL; foreach ($result3 as $k =&gt; $v) &#123; if ($k &gt; $totalNum) &#123; break; &#125; echo $v . PHP_EOL; &#125;&#125;webPuk();echo \"&lt;/br&gt;\";echo \"&lt;a href='./run.php'&gt;重新发牌&lt;/a&gt;\"; 效果如下:玩家1: H1 D10 HK CQ S2玩家2: DQ D9 S2 D8 C9玩家3: C3 H3 DJ H3 H4 重新发牌 这里牌的颜色翻译就不写了, 本来打算写完自动算出哪个玩家胜利, 参考上篇参考中篇参考下篇 看完以后整个人 体验","categories":[],"tags":[]},{"title":"php实现异步调用","slug":"php实现异步调用","date":"2018-10-20T11:24:27.000Z","updated":"2020-01-01T11:48:30.381Z","comments":true,"path":"2018/10/20/php实现异步调用/","link":"","permalink":"https://www.baidu.com/2018/10/20/php%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/","excerpt":"","text":"php默认的请求方式是同步的, 即发送请求必须等到服务端响应才可进行下一步操作。这个默认的机制，导致碰到一些需求会很尴尬. 如:注册时, 掉用了第三方的api服务(人脸识别, 身份证识别啥啥啥的) 这个时候就尴尬了，你的界面必须等待第三方返回方可进行下一步，这对用户的体验是个很大的障碍。 这个时候就很适合用异步请求了。只需要调用第三方api无需等待响应。 下面是个核心的demo。去掉了具体的实现逻辑… ignore_user_abort(true) 客户端断开连接，是否中断脚本set_time_limit(0) 脚本执行时间没有限制 12345678910111213141516171819202122232425ignore_user_abort(true); set_time_limit(0);function asynRequest($url) &#123; $fp = fsockopen($url, 80, $errno, $errstr, 10); if (false === $fp) &#123; echo \"连接失败\"; die; &#125; $out = \"GET /api.php?age=8&amp;name=getin HTTP/1.1 \\r\\n\"; $out .= \"Host: \". $url . \"\\r\\n\"; $out .= \"Connection:Close \\r\\n\\r\\n\"; fwrite($fp, $out); //echo fread($fp, 1024); fclose($fp); return true;&#125;asynRequest(\"www.doman.com\"); //程序执行到这里的时候, 不会等待www.doman.com/api.php的返回结果，而是跳过等待。echo 1; // ?","categories":[],"tags":[]},{"title":"玩玩截取查找字符串","slug":"玩玩截取查找字符串","date":"2017-12-30T14:00:23.000Z","updated":"2020-01-01T11:42:09.249Z","comments":true,"path":"2017/12/30/玩玩截取查找字符串/","link":"","permalink":"https://www.baidu.com/2017/12/30/%E7%8E%A9%E7%8E%A9%E6%88%AA%E5%8F%96%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function inNum()&#123; echo \"enter money: \"; $num = trim(fgets(STDIN)); $w = strpos($num, 'w'); //记录下标 $k = strpos($num, 'k'); if ($w !== false) &#123; $fast = mb_substr($num, 0, $w); $wnum = (int)$fast . '0000' . PHP_EOL; if ($k !== false) &#123; $i = $k - $w - 1; //w和k之间的位数 $kn = mb_substr($num, $w+1, $i); if ($kn &lt;= 9) &#123; $kn = $kn . '000'; &#125; if ($kn &lt;= 99) &#123; $kn = $kn . '00'; &#125; if ($kn &lt;= 999) &#123; $kn = $kn. '0'; &#125; $len = strlen($num) - 1; $mo = 0; if ($len &gt; $k) &#123; //k后面还有数字 $mo = mb_substr($num, $k+1); //截取k后面的数字 if (strlen($mo) &lt; 1) &#123; $mo = $mo . '0'; &#125; &#125; echo (int)$wnum + (int)$kn + (int)$mo . PHP_EOL; die; &#125; echo $wnum; &#125; elseif ($k !== false) &#123; $fast = mb_substr($num, 0, $k); if ($fast &lt;= 9) &#123; $fast = $fast . '000'; &#125; if ($fast &lt;= 99) &#123; $fast = $fast . '00'; &#125; if ($fast &lt;= 999) &#123; $fast = $fast . '0'; &#125; echo $fast . PHP_EOL; &#125; else &#123; echo $num . PHP_EOL; &#125;&#125;inNum(); 效果图","categories":[],"tags":[]},{"title":"php实现冒泡排序","slug":"冒泡排序","date":"2017-05-17T10:38:01.000Z","updated":"2020-01-20T13:24:23.243Z","comments":true,"path":"2017/05/17/冒泡排序/","link":"","permalink":"https://www.baidu.com/2017/05/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序的概念, 就是相邻的元素进行比较, 条件成立交换位置 123456789101112131415161718&lt;?phpfunction simpleSort(array $data) &#123; //从第一个元素开始比较 for ($i = 0, $count = count($data); $i &lt; $count; $i++) &#123; //跟相邻的元素比较 for ($n = $i + 1; $n &lt; $count; $n++) &#123; if ($data[$i] &lt; $data[$n]) &#123; //满足条件就交换位置 list($data[$i], $data[$n]) = [$data[$n], $data[$i]]; &#125; &#125; &#125; return $data;&#125;print_r(simpleSort([1,12,6,33,7,47,66,84,51]));?&gt; 运行结果:Array ( [0] =&gt; 84 [1] =&gt; 66 [2] =&gt; 51 [3] =&gt; 47 [4] =&gt; 33 [5] =&gt; 12 [6] =&gt; 7 [7] =&gt; 6 [8] =&gt; 1 )","categories":[],"tags":[]},{"title":"微测foreach和array_map的执行速度","slug":"微测foreach和array-map的执行速度","date":"2017-01-17T10:00:27.000Z","updated":"2020-01-17T10:21:03.344Z","comments":true,"path":"2017/01/17/微测foreach和array-map的执行速度/","link":"","permalink":"https://www.baidu.com/2017/01/17/%E5%BE%AE%E6%B5%8Bforeach%E5%92%8Carray-map%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6/","excerpt":"","text":"foreach 和 array_map 谁的执行速度比较快? 今天闲的蛋疼, 写了个小demo test 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php$data = [ ['name' =&gt; 'salina', 'age' =&gt; 16, 'sex' =&gt; 0, 'status' =&gt; 0],];ini_set('memory_limit', '-1');for ($i = 0; $i &lt; 9999999; $i++) &#123; array_push($data, ['name' =&gt; 'liya' . $i, 'age' =&gt; 22, 'sex' =&gt; 0, 'status' =&gt;1]);&#125;$begin = microtime(true);$data = array_map(function($v) &#123; if ($v['status'] === 1) &#123; //一些简单的转换 $v['status'] = '激活'; &#125; else &#123; $v['status'] = '禁用'; &#125; if ($v['sex'] === 1) &#123; $v['sex'] = '男'; &#125; else &#123; $v['sex'] = '女'; &#125; return $v;&#125;, $data);$end = microtime(true);$min = microtime(true);foreach ($data as $k =&gt; &amp;$v) &#123; if ($v['status'] === 1) &#123; $v['status'] = '激活'; &#125; else &#123; $v['status'] = '禁用'; &#125; if ($v['sex'] === 1) &#123; $v['sex'] = '男'; &#125; else &#123; $v['sex'] = '女'; &#125;&#125;$max = microtime(true);echo 'array_map time: ' . ($end - $begin) . PHP_EOL;echo 'foreach time: ' . ($max - $min) . PHP_EOL;?&gt; 执行几次测试结果:array_map time: 5.3077862262726foreach time: 2.8736588954926——————————————————-华丽的分割线array_map time: 8.4756429195404foreach time: 12.029865980148——————————————————-华丽的分割线2array_map time: 5.2941391468048foreach time: 2.8984580039978——————————————————-华丽的分割线3array_map time: 5.5151488780975foreach time: 7.3730530738831——————————————————-华丽的分割线4array_map time: 5.3060140609741foreach time: 2.8992168903351——————————————————-华丽的分割线5array_map time: 5.3467030525208foreach time: 5.5229871273041——————————————————-华丽的分割线6 结局并不是很理想…","categories":[],"tags":[]},{"title":"闲聊打怪升级之路","slug":"闲聊打怪升级之路","date":"2016-12-31T05:33:31.000Z","updated":"2020-01-01T12:24:27.449Z","comments":true,"path":"2016/12/31/闲聊打怪升级之路/","link":"","permalink":"https://www.baidu.com/2016/12/31/%E9%97%B2%E8%81%8A%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"比如翻文档的时候, 你遇到了这个数组array_walk？what ?这是干啥的。 然后本着不弄明白不回头的心情点开进去看了下介绍如下1234array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] ) : bool将用户自定义函数 funcname 应用到 array 数组中的每个单元。array_walk() 不会受到 array 内部数组指针的影响。array_walk() 会遍历整个数组而不管指针的位置。哦 callback? callback是啥， 于是乎跳转链接google回调函数-&gt;搜到了匿名函数, 匿名函数是啥？ 跳回了手册 搜索匿名函数。123匿名函数（Anonymous functions，也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。匿名函数目前是通过 Closure 类来实现的。哦，闭包函数? 闭包函数是啥, 于是乎继续往下翻, 这时候忽然又发现了个叫协程的好玩意。 听起来就有兴趣学习 最后…协程是什么, 怎么怎么看着看着又推荐我swoole。 swoole是啥? 打开一看 哦。。swoole是个用c写的php的扩展。。。 于是git clone swoole.git到本地..","categories":[],"tags":[]},{"title":"mysql远程登录","slug":"mysql远程登录","date":"2016-12-20T14:31:57.000Z","updated":"2020-01-28T13:55:09.986Z","comments":true,"path":"2016/12/20/mysql远程登录/","link":"","permalink":"https://www.baidu.com/2016/12/20/mysql%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","excerpt":"","text":"如果设置了mysql的host为%，并且在/etc/my.conf下吧bind=address=120.0.0.1注释了还是登录不了的话 可能是服务器运营商的安全组设置问题 其实整体思路就是用测试工具连接看是否能连接 我这里用了nc ip port比如php $ nc 44.56.34.33 3306 如果提示连接失败就是以上的原因了","categories":[],"tags":[]}]}